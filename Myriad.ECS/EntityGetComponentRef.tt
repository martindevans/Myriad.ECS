<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
using Myriad.ECS.Collections;
using Myriad.ECS.Worlds;
using System.Diagnostics.CodeAnalysis;
using Myriad.ECS.IDs;

namespace Myriad.ECS;

/* dotcover disable */

// ReSharper disable RedundantTypeArgumentsOfMethod

public readonly partial struct EntityId
{
<# for (var i = 2; i <= 16; i++)
{
    var queryConstraints = string.Join(", ", Enumerable.Range(0, i).Select(x => "where T" + x + " : IComponent"));
    var types = string.Join(", ", Enumerable.Range(0, i).Select(x => "T" + x));
#>
    /// <summary>
    /// Get a tuple of several components
    /// </summary>
    <#= CoverageAttribute(i) #>
    public RefTuple<<#= types #>> GetComponentRef<<#= types #>>(World world)
        where <#= Constraints(i, 8) #>
    {
        ref var entityInfo = ref world.GetEntityInfo(this);

        return entityInfo.Chunk.GetRefTuple<<#= types #>>(
            entityInfo.RowIndex,
<# for (var j = 0; j < i; j++)
{
    var comma = (j == (i - 1)) ? "" : ",";
#>
            ComponentID<T<#= j #>>.ID<#= comma #>
<#
}
#>
        );
    }

    /// <summary>
    /// Try to get a tuple of several components, returns false if the entity does not exist or if any of the components
    /// are missing.
    /// </summary>
    <#= CoverageAttribute(i) #>
    public bool TryGetComponentRef<<#= types #>>(World world, out RefTuple<<#= types #>> output)
        where <#= Constraints(i, 8) #>
    {
        // Try to get entity info ref, returns ref to dummy if not
        EntityInfo dummy = default;
        ref var entityInfo = ref world.GetEntityInfo(this, ref dummy, out var isNotExists);

        // If it doesn't exist it doesn't have the components!
        if (isNotExists)
        {
            output = default;
            return false;
        }

        // Get a cached list of components that has been sorted
        var components = SortedListOfComponents<<#= types #>>.Components;

        // Check if they are all in the components set
        var hasComponents = entityInfo.Chunk.Archetype.Components.IsSupersetOfSortedSpan(components.Span);
        if (!hasComponents)
        {
            output = default;
            return false;
        }

        // Get the components
        output = entityInfo.Chunk.GetRefTuple<<#= types #>>(
            entityInfo.RowIndex,
<# for (var j = 0; j < i; j++)
{
    var comma = (j == (i - 1)) ? "" : ",";
#>
            ComponentID<T<#= j #>>.ID<#= comma #>
<#
}
#>
        );
        return true;
    }

    /// <summary>
    /// Check if this entity contains a tuple of several components
    /// </summary>
    <#= CoverageAttribute(i) #>
    public bool HasComponent<<#= types #>>(World world)
        where <#= Constraints(i, 8) #>
    {
        // Try to get entity info ref, returns ref to dummy if not
        EntityInfo dummy = default;
        ref var entityInfo = ref world.GetEntityInfo(this, ref dummy, out var isNotExists);

        // If it doesn't exist it doesn't have the components!
        if (isNotExists)
            return false;

        // Get a cached list of components that has been sorted
        var components = SortedListOfComponents<<#= types #>>.Components;

        // Check if they are all in the components set
        return entityInfo.Chunk.Archetype.Components.IsSupersetOfSortedSpan(components.Span);
    }

<#
}
#>
}

public readonly partial record struct Entity
{
<# for (var i = 2; i <= 16; i++)
{
    var queryConstraints = string.Join(", ", Enumerable.Range(0, i).Select(x => "where T" + x + " : IComponent"));
    var types = string.Join(", ", Enumerable.Range(0, i).Select(x => "T" + x));
#>
    /// <summary>
    /// Get a tuple of several components
    /// </summary>
    <#= CoverageAttribute(i) #>
    public RefTuple<<#= types #>> GetComponentRef<<#= types #>>()
        where <#= Constraints(i, 8) #>
    {
        return ID.GetComponentRef<<#= types #>>(World);
    }

    /// <summary>
    /// Try to get a tuple of several components, returns false if the entity does not exist or if any of the components
    /// are missing.
    /// </summary>
    <#= CoverageAttribute(i) #>
    public bool TryGetComponentRef<<#= types #>>(out RefTuple<<#= types #>> output)
        where <#= Constraints(i, 8) #>
    {
        return ID.TryGetComponentRef<<#= types #>>(World, out output);
    }

    /// <summary>
    /// Get a tuple of several components
    /// </summary>
    <#= CoverageAttribute(i) #>
    public bool HasComponent<<#= types #>>()
        where <#= Constraints(i, 8) #>
    {
        return ID.HasComponent<<#= types #>>(World);
    }

<#
}
#>
}

<#+ 
    static string CoverageAttribute(int index)
	{
		if (index < 3)
			return "";
		return "[ExcludeFromCodeCoverage]";
	}

	static string Constraints(int count, int spaces = 4)
    {
		var prefix = new string(' ', spaces);
        var str = string.Join(
			$"\r\n{prefix}where ",
			Enumerable.Range(0, count).Select(x => $"T{x} : IComponent")
		);

		return str;
    }
#>